# 阶段 1.4 行动指南：核心上报机制与缓存队列调度

本阶段我们将实现 SDK 最核心的**发送功能**，并且直接完成进阶要求中的**“合并上报”**功能。
为了不影响业务页面的性能，我们不会每次触发事件都发请求，而是把数据放进“队列”里，达到一定数量或一定时间后，再统一打包发送。

请按照以下步骤操作：

## 步骤 1：封装底层请求函数 (使用 `sendBeacon`)

在 `packages/sdk/src/utils` 目录下新建文件 `request.ts`。

**说明**：`navigator.sendBeacon` 是浏览器专门为埋点上报提供的 API，它可以在页面关闭时**异步无阻塞**地发送数据，不会延迟页面的卸载。如果浏览器不支持，我们降级使用带有 `keepalive: true` 的 `fetch`。

将以下代码复制到 `packages/sdk/src/utils/request.ts` 中：

```typescript
export const sendRequest = (url: string, data: any) => {
  // 将数据转为 JSON 字符串
  const body = JSON.stringify(data);

  // 1. 优先使用 navigator.sendBeacon (适合在页面卸载时发送数据，无阻塞)
  if (navigator.sendBeacon) {
    // sendBeacon 默认发送 text/plain，如果要后端识别为 JSON，可以使用 Blob 包装
    const blob = new Blob([body], { type: 'application/json' });
    const success = navigator.sendBeacon(url, blob);
    if (success) return;
  }

  // 2. 降级方案：使用 fetch API (开启 keepalive 保证页面关闭时请求也能发出去)
  if (window.fetch) {
    fetch(url, {
      method: 'POST',
      body,
      headers: {
        'Content-Type': 'application/json',
      },
      keepalive: true, // 关键：允许在页面卸载后继续发送请求
    }).catch((err) => {
      console.error('TrackPoint SDK 上报失败:', err);
    });
  }
};
```

## 步骤 2：更新类型声明

打开 `packages/sdk/src/types/index.ts`，为初始化配置增加队列相关的参数。

在 `InitOptions` 接口中增加 `batchSize` 和 `batchDelay`：

```typescript
export interface InitOptions {
  project_id: string;
  requestUrl: string;
  upload_percent?: number;
  
  // --- 新增队列相关配置 ---
  /** 达到多少条数据时触发上报 (默认 5 条) */
  batchSize?: number;
  /** 延迟上报的时间间隔，单位 ms (默认 3000 ms) */
  batchDelay?: number;
}
```

## 步骤 3：改造 `Tracker` 类，实现队列与上报逻辑

这是最核心的一步！打开 `packages/sdk/src/core/Tracker.ts`，我们需要引入请求函数、环境信息，并加入队列调度的逻辑。

请将 `Tracker.ts` 的内容**完全替换**为以下代码：

```typescript
import { InitOptions } from '../types';
import { getEnvInfo } from '../utils/env';
import { sendRequest } from '../utils/request';

export class Tracker {
  private static instance: Tracker | null = null;
  private options: InitOptions | null = null;
  private commonParams: Record<string, any> = {};
  private envInfo: Record<string, any> = {};

  // --- 队列相关属性 ---
  private queue: any[] = [];
  private timer: ReturnType<typeof setTimeout> | null = null;
  private batchSize: number = 5; // 默认 5 条
  private batchDelay: number = 3000; // 默认 3 秒

  private constructor() {}

  public static getInstance(): Tracker {
    if (!this.instance) {
      this.instance = new Tracker();
    }
    return this.instance;
  }

  public register(options: InitOptions) {
    this.options = options;
    // 覆盖默认的队列配置
    if (options.batchSize) this.batchSize = options.batchSize;
    if (options.batchDelay) this.batchDelay = options.batchDelay;

    // 初始化获取环境信息
    this.envInfo = getEnvInfo();
    
    // 监听页面卸载，确保遗留数据被清空上报
    this.initUnloadListener();

    console.log('TrackPoint SDK 注册成功', this.options);
    console.log('当前环境信息:', this.envInfo);
  }

  public addCommonParams(params: Record<string, any>) {
    this.commonParams = {
      ...this.commonParams,
      ...params,
    };
    console.log('添加通用参数成功', this.commonParams);
  }

  // --- 核心：发送事件 ---
  public sendEvent(eventName: string, params?: Record<string, any>) {
    if (!this.options) {
      console.error('TrackPoint SDK 尚未初始化，请先调用 register()');
      return;
    }

    // 1. 组装完整的一条埋点数据
    const eventData = {
      event_name: eventName,
      event_params: params || {},
      common_params: this.commonParams,
      env_info: this.envInfo,
      timestamp: Date.now(), // 记录事件发生的时间
    };

    // 2. 推入队列
    this.queue.push(eventData);

    // 3. 检查队列是否需要触发上报
    this.checkQueue();
  }

  // --- 队列检查逻辑 ---
  private checkQueue() {
    // 策略 1：达到最大缓存数量，立即上报
    if (this.queue.length >= this.batchSize) {
      this.flush();
      return;
    }

    // 策略 2：如果没有定时器，则开启一个定时器，倒计时结束后上报
    if (!this.timer) {
      this.timer = setTimeout(() => {
        this.flush();
      }, this.batchDelay);
    }
  }

  // --- 立即清空队列并上报 ---
  public flush() {
    if (this.queue.length === 0 || !this.options) return;

    // 清除定时器
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }

    // 拷贝当前队列数据，并清空原队列
    const dataToSend = [...this.queue];
    this.queue = [];

    console.log(`[TrackPoint] 触发上报，共 ${dataToSend.length} 条数据`);
    
    // 组装最终发给后端的 Payload 格式
    const payload = {
      project_id: this.options.project_id,
      logs: dataToSend
    };

    // 调用底层请求函数
    sendRequest(this.options.requestUrl, payload);
  }

  // --- 监听页面卸载 ---
  private initUnloadListener() {
    // pagehide 比 beforeunload 更可靠，特别是在移动端
    window.addEventListener('pagehide', () => {
      this.flush();
    });
    // 兼容老浏览器
    window.addEventListener('beforeunload', () => {
      this.flush();
    });
  }
}
```


原来Tracker类

```
import { InitOptions, CommonParams } from "../types";

  

import { getEnvInfo } from "../utils/env";

  

export class Tracker {

  /**

   * 保存初始化配置

   */

  private options: InitOptions;

  

  /**

   * 保存通过 addCommonParams 动态添加的通用参数

   */

  private commonParams: CommonParams;

  

  constructor() {

    // 默认配置

    this.options = {

      project_id: "",

      requestUrl: "",

      upload_percent: 1,

      batchWaitTime: 3000,

      batchMaxLength: 5,

    };

    this.commonParams = {};

  }

  

  /**

   * 页面初始化：注册埋点基础信息

   * @param options 初始化配置项

   */

  public register(options: InitOptions): void {

    // 合并用户配置与默认配置

    this.options = { ...this.options, ...options };

    console.log("[TrackPoint] SDK 初始化成功", this.options);

  }

  

  /**

   * 添加通用参数：允许在任意时刻添加埋点上报时默认带上的参数

   * @param params 键值对对象

   */

  public addCommonParams(params: CommonParams): void {

    // 合并新的参数到已有的通用参数中

    this.commonParams = { ...this.commonParams, ...params };

    console.log("[TrackPoint] 通用参数已更新", this.commonParams);

  }

  

  // ==== 供内部或测试使用的获取方法（非必选，仅为验证） ====

  public getOptions() {

    return this.options;

  }

  public getCommonParams() {

    return this.commonParams;

  }

  

  /**

   * 获取当前采集到的环境信息

   */

  public getEnv() {

    return getEnvInfo();

  }

}

  

// 导出一个单例实例供全局使用

export const tracker = new Tracker();
```

## 步骤 4：在 `test.ts` 中验收测试

打开 `packages/sdk/test.ts`，修改测试代码，模拟连续触发多个事件，观察队列合并效果：

```typescript
import { Tracker } from './src/core/Tracker';

const tracker = Tracker.getInstance();

// 1. 初始化
tracker.register({
  project_id: 'test_project_001',
  requestUrl: 'http://localhost:3000/api/track/upload',
  batchSize: 3, // 为了方便测试，我们设置满 3 条就上报
  batchDelay: 5000 // 或者等 5 秒上报
});

// 2. 添加通用参数
tracker.addCommonParams({
  user_vip_level: 'V1',
  theme: 'dark'
});

// 3. 模拟业务触发事件
console.log('--- 准备触发第 1 个事件 ---');
tracker.sendEvent('click_button', { button_id: 'btn_login' });

setTimeout(() => {
  console.log('--- 准备触发第 2 个事件 ---');
  tracker.sendEvent('view_page', { page_name: 'home' });
}, 1000);

setTimeout(() => {
  console.log('--- 准备触发第 3 个事件 (此时应触发上报!) ---');
  tracker.sendEvent('click_banner', { banner_id: 'ad_001' });
}, 2000);

setTimeout(() => {
  console.log('--- 准备触发第 4 个事件 (进入新队列，等 5 秒后超时上报) ---');
  tracker.sendEvent('scroll_bottom');
}, 3000);
```

## 步骤 5：执行测试与验收

1. 在终端执行 `npm run dev`（如果已经在运行则无需重启）。
2. 在浏览器中打开 `packages/sdk/index.html`。
3. **打开浏览器的开发者工具 (F12) -> Network (网络) 面板**，并勾选 `Preserve log` (保留日志)。
4. 观察 Console 面板和 Network 面板：
   - 第 1 秒、第 2 秒，Network 面板应该**没有**发出网络请求。
   - 第 3 秒（触发第 3 个事件时），因为达到了 `batchSize: 3`，你应该能在 Network 面板看到一个发往 `http://localhost:3000/api/track/upload` 的请求，里面包含了 3 条事件数据！
   - 第 4 秒触发了第 4 个事件，然后等待 5 秒后（大概第 9 秒），由于超时触发，你应该能看到第 2 个网络请求发出，里面包含 1 条事件数据。
   - **终极测试**：刷新页面或关闭页签，观察 Network 面板，你会发现还没来得及上报的数据，会在页面卸载的瞬间通过 `sendBeacon` 发送出去！

---
**请按照以上步骤完成代码修改和测试。如果在 Network 面板成功看到了合并上报的请求，请告诉我，我们就大功告成了！**