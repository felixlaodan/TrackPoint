# 阶段 1.3 行动指南：用户环境信息自动采集

在这一阶段，我们将赋予 SDK“感知环境”的能力。在真实的埋点分析中，用户的设备型号、操作系统、浏览器版本、唯一标识符（UID）是极其重要的数据维度。

我们将编写一个专门的工具模块来提取这些信息，并将它们集成到我们的 `Tracker` 中。

---

## 步骤 1：定义环境信息的类型

首先，我们需要在类型声明文件中定义一下我们即将采集哪些环境数据。

打开 `packages/sdk/src/types/index.ts`，在文件末尾**追加**以下类型定义：

```typescript
// packages/sdk/src/types/index.ts

// ...保留之前的代码...

/**
 * 自动采集的用户环境信息
 */
export interface EnvInfo {
  /** 页面完整 URL */
  url: string;
  /** 页面来源 URL */
  referrer: string;
  /** 用户设备系统 (Windows/macOS/Android/iOS 等) */
  os: string;
  /** 浏览器类型及版本 (Chrome 114/Safari 16 等) */
  browser: string;
  /** 屏幕分辨率 (例如: 1920x1080) */
  screen: string;
  /** 用户唯一标识符 */
  uid: string;
}
```

---

## 步骤 2：编写唯一标识 (UUID) 生成器

如果接入的业务没有主动传 `uid` 给我们，SDK 需要自己给当前浏览器生成一个永不重复的 UUID，并存在 `localStorage` 里，以便能统计 UV（独立访客）。

1. 在 `packages/sdk/src` 下新建文件夹 `utils`。
2. 在 `utils` 文件夹中新建文件 `uuid.ts`，填入以下代码：

```typescript
// packages/sdk/src/utils/uuid.ts

/**
 * 生成一个符合 V4 规范的 UUID
 */
export const generateUUID = (): string => {
  let d = new Date().getTime();
  let d2 =
    (typeof performance !== 'undefined' &&
      performance.now &&
      performance.now() * 1000) ||
    0;
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    let r = Math.random() * 16;
    if (d > 0) {
      r = (d + r) % 16 | 0;
      d = Math.floor(d / 16);
    } else {
      r = (d2 + r) % 16 | 0;
      d2 = Math.floor(d2 / 16);
    }
    return (c === 'x' ? r : (r & 0x3) | 0x8).toString(16);
  });
};

const TRACK_UID_KEY = '__track_point_uid__';

/**
 * 获取或生成唯一的 UID
 * 优先从 localStorage 读取，没有则生成并存储
 */
export const getOrGenerateUid = (): string => {
  try {
    let uid = localStorage.getItem(TRACK_UID_KEY);
    if (!uid) {
      uid = generateUUID();
      localStorage.setItem(TRACK_UID_KEY, uid);
    }
    return uid;
  } catch (e) {
    // 兼容不支持 localStorage 的环境（如隐身模式或非浏览器环境）
    return generateUUID();
  }
};
```

---

## 步骤 3：编写环境信息采集工具

接下来，我们要解析浏览器的 `userAgent`，获取系统和浏览器型号。

在 `packages/sdk/src/utils` 文件夹中新建文件 `env.ts`，填入以下代码：

```typescript
// packages/sdk/src/utils/env.ts

import { EnvInfo } from '../types';
import { getOrGenerateUid } from './uuid';

/**
 * 简单解析 userAgent 获取 OS 和 Browser 信息
 * @param ua navigator.userAgent
 */
const parseUserAgent = (ua: string) => {
  let os = 'Unknown';
  let browser = 'Unknown';

  // 粗略判断 OS
  if (ua.indexOf('Windows') > -1) os = 'Windows';
  else if (ua.indexOf('Mac OS X') > -1) os = 'macOS';
  else if (ua.indexOf('Android') > -1) os = 'Android';
  else if (ua.indexOf('iPhone') > -1 || ua.indexOf('iPad') > -1) os = 'iOS';
  else if (ua.indexOf('Linux') > -1) os = 'Linux';

  // 粗略判断 Browser
  if (ua.indexOf('Chrome') > -1 && ua.indexOf('Edg') === -1 && ua.indexOf('OPR') === -1) {
    browser = 'Chrome';
  } else if (ua.indexOf('Safari') > -1 && ua.indexOf('Chrome') === -1) {
    browser = 'Safari';
  } else if (ua.indexOf('Firefox') > -1) {
    browser = 'Firefox';
  } else if (ua.indexOf('Edg') > -1) {
    browser = 'Edge';
  } else if (ua.indexOf('MicroMessenger') > -1) {
    browser = 'Opera';
  } else if (ua.indexOf('Trident') > -1 || ua.indexOf('MSIE') > -1) {
    browser = 'IE';
  }

  return { os, browser };
};

/**
 * 获取当前所有环境信息
 */
export const getEnvInfo = (): EnvInfo => {
  // 如果在 Node 环境（非浏览器环境），提供默认兜底值
  if (typeof window === 'undefined' || typeof navigator === 'undefined') {
    return {
      url: '',
      referrer: '',
      os: 'Node',
      browser: 'Node',
      screen: '0x0',
      uid: 'node-env-uid'
    };
  }

  const { os, browser } = parseUserAgent(navigator.userAgent);
  const screen = `${window.screen.width}x${window.screen.height}`;
  
  return {
    url: window.location.href,
    referrer: document.referrer,
    os,
    browser,
    screen,
    uid: getOrGenerateUid()
  };
};
```

---

## 步骤 4：在 Tracker 中暴露或测试这些信息

目前我们还没有开发核心的上报模块（1.4），但我们可以先把这些环境信息在 `Tracker` 中暴露出来，看看采集得对不对。

打开 `packages/sdk/src/core/Tracker.ts`，我们引入 `getEnvInfo`。

修改 `Tracker.ts` 的内容如下（主要是增加了 `getEnv` 方法）：

```typescript
// packages/sdk/src/core/Tracker.ts
import { InitOptions } from '../types';
import { getEnvInfo } from '../utils/env';

export class Tracker {
  // ... 其他代码保持不变 ...
  private options: InitOptions;
  private commonParams: Record<string, any>;

  constructor() {
    this.options = {
      project_id: '',
      requestUrl: '',
    };
    this.commonParams = {};
  }

  public register(options: InitOptions) {
    this.options = { ...this.options, ...options };
  }

  public addCommonParams(params: Record<string, any>) {
    this.commonParams = { ...this.commonParams, ...params };
  }

  public getOptions() {
    return this.options;
  }

  public getCommonParams() {
    return this.commonParams;
  }

  // ==== 新增这一段 ====
  /**
   * 获取当前采集到的环境信息
   */
  public getEnv() {
    return getEnvInfo();
  }
  // ===================
}
```

---

## 步骤 5：验证与测试！

现在我们用之前建好的 `test.ts` 跑一下，看看环境信息能不能成功拿到。

打开 `packages/sdk/test.ts`，在末尾加两行代码测试环境获取：

```typescript
// packages/sdk/test.ts
import { Tracker } from './src/core/Tracker';

const tracker = new Tracker();

tracker.register({
  project_id: 'test_project',
  requestUrl: 'http://localhost:3000/api/track'
});

tracker.addCommonParams({
  app_version: '1.0.0',
  user_type: 'vip'
});

console.log('--- 测试配置信息 ---');
console.log('Options:', tracker.getOptions());
console.log('Common Params:', tracker.getCommonParams());

// ==== 新增下面这段 ====
console.log('--- 测试环境信息采集 ---');
console.log('Env Info:', tracker.getEnv());
```

在终端（确保在 `packages/sdk` 目录下），运行测试脚本：

```bash
npx tsx test.ts
```

*(说明：由于 `tsx` 是在 Node 环境下运行的，所以它输出的 OS 和 Browser 会显示为 `'Node'`，并且 `uid` 也会兜底输出 `'node-env-uid'`，这是完全正常的，说明我们的兜底逻辑生效了。等我们最后放到浏览器里测试时，它就会显示出真正的 Chrome/Windows 信息。)*

**验收标准**：
如果终端输出了：
```text
--- 测试环境信息采集 ---
Env Info: {
  url: '',
  referrer: '',
  os: 'Node',
  browser: 'Node',
  screen: '0x0',
  uid: 'node-env-uid'
}
```
那么恭喜你，环境信息模块编写成功！

**请你按照以上 5 个步骤一步步操作，看到预期的输出后，告诉我一声，我们就准备进入埋点最硬核的部分 —— 阶段 1.4：核心上报机制与缓存队列调度！**
